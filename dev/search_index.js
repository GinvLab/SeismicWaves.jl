var documenterSearchIndex = {"docs":
[{"location":"guide/#User-guide","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"guide/","page":"User guide","title":"User guide","text":"Warning: User guide is currently work in progress!","category":"page"},{"location":"guide/","page":"User guide","title":"User guide","text":"See the Examples for how to use this package!","category":"page"},{"location":"guide/","page":"User guide","title":"User guide","text":"See the API for detailed information about the functionalities of this package!","category":"page"},{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Input-parameters","page":"API","title":"Input parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SeismicWaves]\nPrivate = false\nFilter = t -> (typeof(t) === DataType || typeof(t) === UnionAll) && (t <: InputParameters)","category":"page"},{"location":"api/#SeismicWaves.InputParameters","page":"API","title":"SeismicWaves.InputParameters","text":"abstract type InputParameters{T, N}\n\nInputParameters is the abstract supertype describing input parameters for wave simulations.\n\nCurrently implemented concrete parameters are InputParametersAcoustic and InputParametersElastic, for acoustic and elasic wave simulation respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.InputParametersAcoustic","page":"API","title":"SeismicWaves.InputParametersAcoustic","text":"struct InputParametersAcoustic{T, N} <: InputParameters{T, N}\n\nParameters for acoustic wave simulations.\n\nntimesteps::Int64: Number of time steps\ndt::Any: Time step\ngridsize::NTuple{N, Int64} where N: Grid size for each dimension\ngridspacing::NTuple{N, T} where {T, N}: Grid spacing in each direction\nboundcond::InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.InputParametersElastic","page":"API","title":"SeismicWaves.InputParametersElastic","text":"struct InputParametersElastic{T, N} <: InputParameters{T, N}\n\nParameters for elastic wave simulations\n\nntimesteps::Int64: Number of time steps\ndt::Any: Time step\ngridsize::NTuple{N, Int64} where N: Grid size for each dimension\ngridspacing::NTuple{N, T} where {T, N}: Grid spacing in each direction\nboundcond::InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#Input-BDCs-parameters","page":"API","title":"Input BDCs parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SeismicWaves]\nPrivate = false\nFilter = t -> (typeof(t) === DataType || typeof(t) === UnionAll) && (t <: InputBoundaryConditionParameters)","category":"page"},{"location":"api/#SeismicWaves.CPMLBoundaryConditionParameters","page":"API","title":"SeismicWaves.CPMLBoundaryConditionParameters","text":"struct CPMLBoundaryConditionParameters{T} <: InputBoundaryConditionParameters{T}\n\nCPML boundary conditions parameters for wave simulations.\n\nhalo::Int64: Number of CPML grid points\nrcoef::Any: Target reflection coefficient\nfreeboundtop::Bool: Free surface boundary condition at the top\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.InputBoundaryConditionParameters","page":"API","title":"SeismicWaves.InputBoundaryConditionParameters","text":"abstract type InputBoundaryConditionParameters{T}\n\nInputBoundaryConditionParameters is the abstract supertype describing boundary conditions input parameters for wave simulations.\n\nCurrently implemented concrete parameters are CPMLBoundaryConditionParameters and ReflectiveBoundaryConditionParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ReflectiveBoundaryConditionParameters","page":"API","title":"SeismicWaves.ReflectiveBoundaryConditionParameters","text":"struct ReflectiveBoundaryConditionParameters{T, N} <: InputBoundaryConditionParameters{T}\n\nReflective boundary conditions parameters for wave simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Material-properties","page":"API","title":"Material properties","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SeismicWaves]\nPrivate = false\nFilter = t -> (typeof(t) === DataType || typeof(t) === UnionAll) && (t <: MaterialProperties)","category":"page"},{"location":"api/#SeismicWaves.ElasticIsoMaterialProperties","page":"API","title":"SeismicWaves.ElasticIsoMaterialProperties","text":"struct ElasticIsoMaterialProperties{T, N} <: SeismicWaves.AbstrElasticIsoMaterialProperties{T, N}\n\nMaterial properties for elastic isotropic simulation.\n\nλ::Array: First Lamé parameter\nμ::Array: Second Lamé parameter (shear modulus)\nρ::Array: Density\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.MaterialProperties","page":"API","title":"SeismicWaves.MaterialProperties","text":"abstract type MaterialProperties{T, N}\n\nMaterialProperties is the abstract supertype describing material properties for wave simulations. It defines which type of wave equation is solved.\n\nCurrently implemented concrete properties are:\n\nVpAcousticCDMaterialProperties for acoustic constant density wave equation\nVpRhoAcousticVDMaterialProperties for acoustic variable density wave equation\nElasticIsoMaterialProperties for elasitic isotropic wave equation\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VpAcousticCDMaterialProperties","page":"API","title":"SeismicWaves.VpAcousticCDMaterialProperties","text":"struct VpAcousticCDMaterialProperties{T, N} <: MaterialProperties{T, N}\n\nMaterial properties for acoustic constant-density simulation.\n\nvp::Array: P-wave velocity\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VpRhoAcousticVDMaterialProperties","page":"API","title":"SeismicWaves.VpRhoAcousticVDMaterialProperties","text":"mutable struct VpRhoAcousticVDMaterialProperties{T, N} <: MaterialProperties{T, N}\n\nMaterial properties for acoustic variable-density simulation.\n\nvp::Array: P-wave velocity\nrho::Array: Density\ninterp_method::SeismicWaves.InterpolationMethod: Interpolation method\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VpRhoAcousticVDMaterialProperties-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}} where {T, N}","page":"API","title":"SeismicWaves.VpRhoAcousticVDMaterialProperties","text":"VpRhoAcousticVDMaterialProperties(\n  vp::Array{T, N},\n  rho::Array{T, N};\n  interp_method::InterpolationMethod=ArithmeticAverageInterpolation(2)\n) where {T, N}\n\nConstructor for material properties for acoustic variable-density simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Shots,-sources-and-receivers","page":"API","title":"Shots, sources and receivers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SeismicWaves]\nPrivate = false\nFilter = t -> (typeof(t) === DataType || typeof(t) === UnionAll) && (t <: Shot || t <: Sources || t <: Receivers)","category":"page"},{"location":"api/#SeismicWaves.MomentTensorShot","page":"API","title":"SeismicWaves.MomentTensorShot","text":"struct MomentTensorShot{T, N, M<:SeismicWaves.MomentTensor{T, N}} <: Shot{T}\n\nType representing a shot with moment tensor sources and multi-component receivers.\n\nsrcs::MomentTensorSources: Structure containing the MomentTensorSources for a given simulation.\nrecs::VectorReceivers: Structure containing the VectorReceivers for a given simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.MomentTensorSources","page":"API","title":"SeismicWaves.MomentTensorSources","text":"Type representing a multi-source configuration for a wave propagation shot.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.MomentTensorSources-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Vector{M}, T}} where {T, N, M<:SeismicWaves.MomentTensor{T, N}}","page":"API","title":"SeismicWaves.MomentTensorSources","text":"MomentTensorSources( \n    positions::Matrix{T},\n    tf::Matrix{T},\n    momtens::Vector{M}\n    domfreq::T\n) where {T, N, M <: MomentTensor{T}}\n\nCreate a single shot wave propagation source configuration from source positions, time-functions and a dominant frequency.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.Receivers","page":"API","title":"SeismicWaves.Receivers","text":"abstract type Receivers{T}\n\nSources is the abstract supertype describing seismic receivers.\n\nCurrently implemented concrete receivers types are:\n\nScalarReceivers for scalar field receivers\nVectorReceivers for vector field receivers\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarReceivers","page":"API","title":"SeismicWaves.ScalarReceivers","text":"struct ScalarReceivers{T} <: Receivers{T}\n\nType representing a multi-receiver configuration for a wave propagation shot.\n\npositions::Matrix: Receiver positions\nseismograms::Matrix: Array holding seismograms (as columns)\nobserved::Matrix: Array holding observed seismograms (as columns)\ninvcov::AbstractMatrix: Inverse of the covariance matrix\nwindows::Vector{Pair{Int64, Int64}}: Windows of data used for misfit calculations\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarReceivers-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T","page":"API","title":"SeismicWaves.ScalarReceivers","text":" ScalarReceivers(\n   positions::Matrix{T},\n   nt::Int;\n   observed::Union{Matrix{T}, Nothing}=nothing,\n   invcov::Union{AbstractMatrix{T}, Nothing}=nothing,\n   windows::Union{Vector{Pair{Int,Int}}, Nothing}=nothing\n ) where {T}\n\nScalarReceivers(\n    positions::Array{T, 2},\n    nt::Int64;\n    observed,\n    invcov,\n    windows\n) -> ScalarReceivers\n\n\nCreate a single shot wave propagation receivers configuration from receivers positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.ScalarShot","page":"API","title":"SeismicWaves.ScalarShot","text":"struct ScalarShot{T} <: Shot{T}\n\nType representing a shot with scalar sources and receivers.\n\nsrcs::ScalarSources: Structure containing the ScalarSources for a given simulation.\nrecs::ScalarReceivers: Structure containing the ScalarReceivers for a given simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarSources","page":"API","title":"SeismicWaves.ScalarSources","text":"struct ScalarSources{T} <: Sources{T}\n\nType representing a multi-source configuration for a wave propagation shot.\n\npositions::Matrix: Source positions\ntf::Matrix: Source time function\ndomfreq::Any: Dominant frequency\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarSources-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T}} where T","page":"API","title":"SeismicWaves.ScalarSources","text":"ScalarSources(positions::Matrix{T}, tf::Matrix{T}, domfreq::T) where {T}\n\nCreate a single shot wave propagation source configuration from source positions, time-functions and a dominant frequency.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.Shot","page":"API","title":"SeismicWaves.Shot","text":"abstract type Shot{T}\n\nShot is the abstract supertype describing a shot composed of sources and receivers.\n\nCurrently implemented concrete shot types are:\n\nScalarShot for scalar field sources and receivers\nMomentTensorShot for moment tensor sources and vector field receivers\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.Sources","page":"API","title":"SeismicWaves.Sources","text":"abstract type Sources{T}\n\nSources is the abstract supertype describing seismic sources.\n\nCurrently implemented concrete sources types are:\n\nScalarSources for scalar field sources\nMomentTensorSources for moment tensor sources\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VectorReceivers","page":"API","title":"SeismicWaves.VectorReceivers","text":"struct VectorReceivers{T, N} <: Receivers{T}\n\nType representing a multi-receiver configuration for a wave propagation shot.\n\npositions::Matrix: Receiver positions\nseismograms::Array{T, 3} where T: Array holding seismograms (as columns)\nobserved::Array{T, 3} where T: Array holding observed seismograms (as columns)\ninvcov::AbstractMatrix: Inverse of the covariance matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#Solver-functions","page":"API","title":"Solver functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"swforward!\nswmisfit!\nswgradient!","category":"page"},{"location":"api/#SeismicWaves.swforward!","page":"API","title":"SeismicWaves.swforward!","text":"swforward!(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1};\n    parall,\n    snapevery,\n    infoevery,\n    logger\n) -> Any\n\n\nCompute forward simulation using the given input parameters params and material properties matprop on multiple shots. Receivers traces are stored in the receivers for each shot.\n\nReturn a vector of Dict containing for each shot the snapshots of the fields computed in the simulation for each timestep.\n\nPositional arguments\n\nparams::InputParameters{T, N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation type.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation type.\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\nsnapevery::Union{Int, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays.  \ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\nlogger::Union{Nothing, AbstractLogger} = nothing: if specified, uses the given logger object to print logs, otherwise it uses the logger returned from current_logger().\n\nSee also InputParameters, MaterialProperties and Shot.\n\n\n\n\n\nswforward!(\n    wavesim::Union{WaveSimulation{T, N}, Array{<:WaveSimulation{T, N}, 1}},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1};\n    logger,\n    kwargs...\n) -> Any\n\n\nCompute forward simulation using a previously constructed WaveSimulation object. See also build_wavesim on how to build the WaveSimulation. Receivers traces are stored in the receivers for each shot.\n\nReturn a vector of Dict containing for each shot the snapshots of the fields computed in the simulation for each timestep.\n\nPositional arguments\n\nwavesim: wave simulation object containing all required information to run the simulation.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation type.\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nlogger::Union{Nothing, AbstractLogger} = nothing: if specified, uses the given logger object to print logs, otherwise it uses the logger returned from current_logger().\n\nSee also InputParameters, MaterialProperties and Shot.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.swmisfit!","page":"API","title":"SeismicWaves.swmisfit!","text":"swmisfit!(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1};\n    parall,\n    misfit,\n    logger\n) -> Any\n\n\nReturn the misfit w.r.t. observed data by running a forward simulation using the given input parameters params and material properties matprop on multiple shots. Receivers traces are stored in the receivers for each shot.\n\nPositional arguments\n\nparams::InputParameters{T, N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\nlogger::Union{Nothing,AbstractLogger}: specifies the logger to be used.\n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swgradient! and Shot.\n\n\n\n\n\nswmisfit!(\n    wavesim::Union{WaveSimulation{T, N}, Array{<:WaveSimulation{T, N}, 1}},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1};\n    logger,\n    kwargs...\n) -> Any\n\n\nReturn the misfit w.r.t. observed data by running a forward simulation using the given WaveSimulation object as an input. Receivers traces are stored in the receivers for each shot. See also build_wavesim on how to build the WaveSimulation.\n\nPositional arguments\n\nwavesim::Union{WaveSimulation{T,N},Vector{<:WaveSimulation{T,N}}}: input WaveSimulation object containing all required information to run the simulation.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swgradient! and Shot.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.swgradient!","page":"API","title":"SeismicWaves.swgradient!","text":"swgradient!(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1};\n    parall,\n    check_freq,\n    infoevery,\n    compute_misfit,\n    misfit,\n    smooth_radius,\n    logger\n) -> Any\n\n\nCompute gradients w.r.t. model parameters using the given input parameters params and material parameters matprop on multiple shots.\n\nThe check_freq parameter controls the checkpoiting frequency for adjoint computation. If nothing, no checkpointing is performed. If greater than 2, a checkpoint is saved every check_freq time step. The optimal tradeoff value is check_freq = sqrt(nt) where nt is the number of time steps of the forward simulation. Bigger values speed up computation at the cost of using more memory.\n\nPositional arguments\n\nparams::InputParameters{T, N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ncheck_freq::Union{Int, Nothing} = nothing: if specified, enables checkpointing and specifies the checkpointing frequency.\ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\ncompute_misfit::Bool = false: if true, also computes and return misfit value.\nsmooth_radius::Int = 5: grid points inside a ball with radius specified by the parameter (in grid points) will have their gradient smoothed by a factor inversely proportional to their distance from sources positions.\nlogger::Union{Nothing,AbstractLogger}: specifies the logger to be used.\n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swmisfit! and Shot.\n\n\n\n\n\nswgradient!(\n    wavesim::Union{WaveSimulation{T, N}, Array{<:WaveSimulation{T, N}, 1}},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1};\n    logger,\n    kwargs...\n) -> Any\n\n\nCompute gradients w.r.t. model parameters using the previously built WaveSimulation. This avoids re-initializing and re-allocating several arrays in case of multiple gradient calculations. See also build_wavesim on how to build the WaveSimulation.\n\nThe check_freq parameter controls the checkpoiting frequency for adjoint computation. If nothing, no checkpointing is performed. If greater than 2, a checkpoint is saved every check_freq time step. The optimal tradeoff value is check_freq = sqrt(nt) where nt is the number of time steps of the forward simulation. Bigger values speed up computation at the cost of using more memory.\n\nPositional arguments\n\nwavesim::Union{WaveSimulation{T,N},Vector{<:WaveSimulation{T,N}}}: input WaveSimulation object containing all required information to run the simulation.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ncheck_freq::Union{Int, Nothing} = nothing: if specified, enables checkpointing and specifies the checkpointing frequency.\ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\ncompute_misfit::Bool = false: if true, also computes and return misfit value.\nsmooth_radius::Int = 5: grid points inside a ball with radius specified by the parameter (in grid points) will have their gradient smoothed by a factor inversely proportional to their distance from sources positions.\nlogger::Union{Nothing,AbstractLogger}: specifies the logger to be used. \n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swmisfit! and Shot.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"build_wavesim\ngaussstf\ngaussderivstf\nrickerstf","category":"page"},{"location":"api/#SeismicWaves.build_wavesim","page":"API","title":"SeismicWaves.build_wavesim","text":"build_wavesim(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N};\n    parall,\n    kwargs...\n)\n\n\nBuilds a wave similation based on the input paramters params and keyword arguments kwargs.\n\nPositional arguments\n\nparams::InputParameters{T,N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ngradient::Bool = false: whether the wave simulation is used for gradients computations.\ncheck_freq::Union{<:Int, Nothing} = nothing: if gradient = true and if specified, enables checkpointing and specifies the checkpointing frequency.\nsnapevery::Union{<:Int, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays (only for forward simulations).\ninfoevery::Union{<:Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.gaussstf","page":"API","title":"SeismicWaves.gaussstf","text":"gaussstf(t::Real, t0::Real, f0::Real) -> Real\n\n\nGaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.gaussderivstf","page":"API","title":"SeismicWaves.gaussderivstf","text":"gaussderivstf(t::Real, t0::Real, f0::Real) -> Real\n\n\nFirst derivative of gaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.rickerstf","page":"API","title":"SeismicWaves.rickerstf","text":"rickerstf(t::Real, t0::Real, f0::Real) -> Real\n\n\nRicker source (second derivative of gaussian) source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"examples/","page":"Examples","title":"Examples","text":"EditURL = \"examples.jl\"","category":"page"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Acoustic-wave-simulation-example","page":"Examples","title":"Acoustic wave simulation example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SeismicWaves\n\n# numerics\nnt = 1500\ndt = 0.0012\ndh = 10.0\nt = collect(Float64, range(0.0; step=dt, length=nt)) ## time vector\n\n# create a velocity model (gradient from top to bottom)\nnx = 211\nnz = 120\nvelmod = zeros(nx, nz)\nfor i in 1:nx\n    for j in 1:nz\n        velmod[i, j] = 2000.0 + 12.0 * (j - 1)\n    end\nend\nmatprop = VpAcousticCDMaterialProperties(velmod)\n\n# shots definition\nnshots = 6\nshots = Vector{ScalarShot{Float64}}()\n# sources x-position (in grid points) (different for every shot)\nixsrc = round.(Int, LinRange(32, nx - 31, nshots))\nfor i in 1:nshots\n    # sources definition\n    nsrc = 1\n    possrcs = zeros(1, 2)                ## 1 source, 2 dimensions\n    possrcs[:, 1] .= (ixsrc[i] - 1) * dh    ## x-positions in meters\n    possrcs[:, 2] .= 2 * dh                 ## y-positions in meters\n    # source time functions\n    srcstf = zeros(nt, nsrc)\n    for s in 1:nsrc\n        srcstf[:, s] .= 1000.0 .* rickerstf.(t, 1.20 / 12.0, 12.0)\n    end\n    srcs = ScalarSources(possrcs, srcstf, 12.0)\n\n    # receivers definition\n    nrecs = 20\n    # receivers x-positions (in grid points) (same for every shot)\n    ixrec = round.(Int, LinRange(30, nx - 29, nrecs))\n    posrecs = zeros(nrecs, 2)              ## 20 receivers, 2 dimensions\n    posrecs[:, 1] .= (ixrec .- 1) .* dh    ## x-positions in meters\n    posrecs[:, 2] .= 2 * dh                ## y-positions in meters\n    recs = ScalarReceivers(posrecs, nt)\n\n    # add pair as shot\n    push!(shots, ScalarShot(; srcs=srcs, recs=recs)) ## srcs => recs)\nend\n\n# Input parameters for acoustic simulation\nsnapevery = 100\nboundcond = CPMLBoundaryConditionParameters(; halo=20, rcoef=0.0001, freeboundtop=true)\nparams = InputParametersAcoustic(nt, dt, (nx, nz), (dh, dh), boundcond)\n\n# Compute the seismograms\nsnapshots = swforward!(\n    params,\n    matprop,\n    shots;\n    parall=:threads,\n    snapevery=snapevery\n)","category":"page"},{"location":"examples/#Elastic-wave-simulation-example","page":"Examples","title":"Elastic wave simulation example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# time stuff\nnt = 3000 #1500\ndt = 0.0008\nt = collect(Float64, range(0.0; step=dt, length=nt)) # seconds\n\n# create a velocity model\nnx = 380 ## 211\nnz = 270 ## 120\ndh = 4.5 ## meters\n\nvp = zeros(nx, nz)\nvp[nx÷2+10:end, :] .= 3100.0\nfor i in 1:nx\n    for j in 1:nz\n        vp[i, j] = 2000.0 + dh * (j - 1)\n    end\nend\nvs = vp ./ sqrt(3)\n\nρ = 2100.0 * ones(nx, nz)\nμ = vs .^ 2 .* ρ  ## μ = Vs^2⋅ρ\nλ = (vp .^ 2 .* ρ) .- (2 .* μ)  ## λ = vp^2 · ρ - 2μ\n\nmatprop = ElasticIsoMaterialProperties(; λ=λ, μ=μ, ρ=ρ)\n\n# shots definition\nnshots = 1\nshots = Vector{MomentTensorShot{Float64, 2, MomentTensor2D{Float64}}}()\n\nfor i in 1:nshots\n    # sources definition\n    nsrc = 1\n    # sources x-position (in grid points) (different for every shot)\n    if nsrc == 1\n        ixsrc = [nx / 2]\n    else\n        ixsrc = round.(Int, LinRange(30, nx - 31, nsrc))\n    end\n    possrcs = zeros(nsrc, 2)    ## 1 source, 2 dimensions\n    for s in 1:nsrc\n        possrcs[s, 1] = (ixsrc[i] - 1) * dh .+ 0.124   ## x-positions in meters\n        possrcs[s, 2] = (nz / 2) * dh .+ 0.124 ## y-positions in meters\n    end\n\n    # source time functions\n    f0 = 12.0\n    t0 = 1.20 / f0\n    srcstf = zeros(nt, nsrc)\n    Mxx = zeros(nsrc)\n    Mzz = zeros(nsrc)\n    Mxz = zeros(nsrc)\n    for s in 1:nsrc\n        srcstf[:, s] .= rickerstf.(t, t0, f0)\n        Mxx[s] = 5e10\n        Mzz[s] = 5e10\n        Mxz[s] = 0.89e10\n    end\n\n    srcs = MomentTensorSources(\n        possrcs, srcstf,\n        [MomentTensor2D(; Mxx=Mxx[s], Mzz=Mzz[s], Mxz=Mxz[s]) for s in 1:nsrc],\n        f0\n    )\n\n    # receivers definition\n    nrecs = 10\n    # receivers x-positions (in grid points) (same for every shot)\n    ixrec = round.(Int, LinRange(40, nx - 40, nrecs))\n    posrecs = zeros(nrecs, 2)    ## 20 receivers, 2 dimensions\n    posrecs[:, 1] .= (ixrec .- 1) .* dh .- 0.324   ## x-positions in meters\n    posrecs[:, 2] .= 3 * dh                        ## y-positions in meters\n\n    ndim = 2\n    recs = VectorReceivers(posrecs, nt, ndim)\n\n    # add pair as shot\n    push!(shots, MomentTensorShot(; srcs=srcs, recs=recs)) # srcs => recs)\nend\n\n# Input parameters for elastic simulation\nsnapevery = 5\ninfoevery = 100\nfreetop = true\nhalo = 20\nrcoef = 0.0001\nboundcond = CPMLBoundaryConditionParameters(; halo=halo, rcoef=rcoef, freeboundtop=freetop)\nparams = InputParametersElastic(nt, dt, (nx, nz), (dh, dh), boundcond)\n\n# Compute the seismograms\nsnapshots = swforward!(\n    params,\n    matprop,\n    shots;\n    parall=:threads,\n    infoevery=infoevery,\n    snapevery=snapevery\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://gitlab.com/JuliaGeoph/SeismicWaves.jl/-/tree/main/docs/src/\"","category":"page"},{"location":"#SeismicWaves.jl","page":"Home","title":"SeismicWaves.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeismicWaves.jl is a Julia package for acoustic and elastic wave propagation simulations designed to be used in a Full-Waveform Inversion framework. It solves different flavours of the wave equation using the finite difference method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main features of SeismicWaves.jl are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"forward wave simulations with multiple pairs of sources and receivers (shots)\n1D, 2D, and 3D acoustic wave simulations (constant density and variable density)\n2D P-SV elastic wave similations (isotropic)\nfree boundary and C-PML absorbing boundary conditions supported\ngradients of misfit functions with respect to model parameters using the adjoint method (only acoustic simulations supported as of now)\ncheckpointing of forward simulations for adjoint method\ndevice agnostic backends (CPUs or GPUs) thanks to ParallelStencil.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package additionally provides some functions to solve inverse problems using the Hamiltonian Monte Carlo (HMC) method, as part of the HMCLab framework. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information and an extensive list of features can be found in the documentation, which you can either find online or build locally by running the docs/make.jl file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Warning: Documentation is currently minimal and work in progress!","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Examples for how to use this package!","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the API for detailed information about the functionalities of this package!","category":"page"}]
}
