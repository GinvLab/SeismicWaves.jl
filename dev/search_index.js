var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://gitlab.com/JuliaGeoph/SeismicWaves.jl/-/tree/main/docs/src/\"","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 4","category":"page"},{"location":"#User-guide","page":"Home","title":"User guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeismicWaves is a Julia package for seismic wave propagation using the finite difference method. SeismicWaves provides functions to solve the forward problem and the gradient of a misfit functional with respect to model parameters. This package additionally provides some functions to solve inverse problems using the Hamiltonian Monte Carlo (HMC) method, as part of the HMCLab framework. ","category":"page"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SeismicWaves]\nPrivate = false","category":"page"},{"location":"#SeismicWaves.SeismicWaves","page":"Home","title":"SeismicWaves.SeismicWaves","text":"Module for generalized wave propagation solvers.\n\n\n\n\n\n","category":"module"},{"location":"#SeismicWaves.CPMLBoundaryConditionParameters","page":"Home","title":"SeismicWaves.CPMLBoundaryConditionParameters","text":"struct CPMLBoundaryConditionParameters <: SeismicWaves.InputBoundaryConditionParameters\n\nCPML boundary conditions parameters for wave simulations.\n\nhalo::Int64: Number of CPML grid points\nrcoef::Real: Target reflection coefficient\nfreeboundtop::Bool: Free surface boundary condition at the top\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.InputParametersAcoustic","page":"Home","title":"SeismicWaves.InputParametersAcoustic","text":"struct InputParametersAcoustic{N} <: SeismicWaves.InputParameters{N}\n\nParameters for acoustic wave simulations.\n\nntimesteps::Int64: Number of time steps\ndt::Real: Time step\ngridsize::Tuple{Vararg{var\"#s281\", N}} where {N, var\"#s281\"<:Int64}: Grid size for each dimension\ngridspacing::Tuple{Vararg{var\"#s280\", N}} where {N, var\"#s280\"<:Real}: Grid spacing in each direction\nboundcond::SeismicWaves.InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.InputParametersAcousticVariableDensity","page":"Home","title":"SeismicWaves.InputParametersAcousticVariableDensity","text":"struct InputParametersAcousticVariableDensity{N} <: SeismicWaves.InputParameters{N}\n\nParameters for variable-density acoustic wave simulations.\n\nntimesteps::Int64: Number of time steps\ndt::Real: Time step\ngridsize::Tuple{Vararg{var\"#s281\", N}} where {N, var\"#s281\"<:Int64}: Grid size for each dimension\ngridspacing::Tuple{Vararg{var\"#s280\", N}} where {N, var\"#s280\"<:Real}: Grid spacing in each direction\nboundcond::SeismicWaves.InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.ReflectiveBoundaryConditionParameters","page":"Home","title":"SeismicWaves.ReflectiveBoundaryConditionParameters","text":"struct ReflectiveBoundaryConditionParameters <: SeismicWaves.InputBoundaryConditionParameters\n\nReflective boundary conditions parameters for wave simulations.\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.ScalarReceivers","page":"Home","title":"SeismicWaves.ScalarReceivers","text":"struct ScalarReceivers{T<:Real} <: SeismicWaves.Receivers\n\nType representing a multi-receiver configuration for a wave propagation shot.\n\npositions::Matrix{<:Real}: Receiver positions\nseismograms::Matrix{T} where T<:Real: Array holding seismograms (as columns)\nobserved::Matrix{T} where T<:Real: Array holding observed seismograms (as columns)\ninvcov::AbstractMatrix{T} where T<:Real: Inverse of the covariance matrix\nwindows::Vector{Pair{Int64, Int64}}: Windows of data used for misfit calculations\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.ScalarReceivers-Tuple{Any, Any}","page":"Home","title":"SeismicWaves.ScalarReceivers","text":"ScalarReceivers(positions, nt; observed, invcov, windows)\n\n\nCreate a single shot wave propagation receivers configuration from receivers positions. Default constructor for Float64.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.ScalarReceivers-Union{Tuple{T}, Tuple{Matrix{<:Real}, Integer}} where T<:Real","page":"Home","title":"SeismicWaves.ScalarReceivers","text":" ScalarReceivers{T}(\n   positions::Matrix{<:Real},\n   nt::Integer;\n   observed::Union{Matrix{T}, Nothing}=nothing,\n   invcov::Union{AbstractMatrix{T}, Nothing}=nothing,\n   windows::Union{Vector{Pair{Int,Int}}, Nothing}=nothing\n ) where {T <: Real}\n\nCreate a single shot wave propagation receivers configuration from receivers positions.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.ScalarSources","page":"Home","title":"SeismicWaves.ScalarSources","text":"struct ScalarSources{T<:Real} <: SeismicWaves.Sources\n\nType representing a multi-source configuration for a wave propagation shot.\n\npositions::Matrix{<:Real}: Source positions\ntf::Matrix{T} where T<:Real: Source time function\ndomfreq::Real: Dominant frequency\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.ScalarSources-Tuple{Any, Any, Any}","page":"Home","title":"SeismicWaves.ScalarSources","text":"ScalarSources(positions, tf, domfreq)\n\n\nCreate a single shot wave propagation source configuration from source positions, time-functions and a dominant frequency. Default type constructor for Float64.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.ScalarSources-Union{Tuple{T}, Tuple{Matrix{<:Real}, Matrix{T}, T}} where T<:Real","page":"Home","title":"SeismicWaves.ScalarSources","text":"ScalarSources{T}(positions::Matrix{<:Real}, tf::Matrix{T}, domfreq::T) where {T <: Real}\n\nCreate a single shot wave propagation source configuration from source positions, time-functions and a dominant frequency.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.Shot","page":"Home","title":"SeismicWaves.Shot","text":"struct Shot\n\nType representing a source-receiver pair, i.e., a \"shot\".\n\nsrcs::SeismicWaves.Sources: Structure containing the appropriate Sources for a given simulation.\nrecs::SeismicWaves.Receivers: Structure containing the appropriate Receivers for a given simulation.\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.VpAcousticCDMaterialProperty","page":"Home","title":"SeismicWaves.VpAcousticCDMaterialProperty","text":"struct VpAcousticCDMaterialProperty{N} <: SeismicWaves.MaterialProperties{N}\n\nMaterial properties for acoustic constant-density simulation.\n\nvp::Array{<:Float64, N} where N: P-wave velocity\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.VpRhoAcousticVDMaterialProperty","page":"Home","title":"SeismicWaves.VpRhoAcousticVDMaterialProperty","text":"mutable struct VpRhoAcousticVDMaterialProperty{N} <: SeismicWaves.MaterialProperties{N}\n\nMaterial properties for acoustic variable-density simulation.\n\nvp::Array{<:Float64, N} where N: P-wave velocity\nrho::Array{<:Float64, N} where N: Density\ninterp_method::SeismicWaves.InterpolationMethod: Interpolation method\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.VpRhoAcousticVDMaterialProperty-Tuple{Any, Any}","page":"Home","title":"SeismicWaves.VpRhoAcousticVDMaterialProperty","text":"VpRhoAcousticVDMaterialProperty(vp, rho; kwargs...)\n\n\nConstructor to avoid specifying dimensions to create material properties for acoustic variable-density simulation.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.VpRhoAcousticVDMaterialProperty-Union{Tuple{N}, Tuple{Array{<:Float64, N}, Array{<:Float64, N}}} where N","page":"Home","title":"SeismicWaves.VpRhoAcousticVDMaterialProperty","text":"VpRhoAcousticVDMaterialProperty{N}(\n  vp::Array{<:Float64, N},\n  rho::Array{<:Float64, N};\n  interp_method::InterpolationMethod=ArithmeticAverageInterpolation(2)\n) where {N}\n\nConstructor for material properties for acoustic variable-density simulation.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.WaveSimul","page":"Home","title":"SeismicWaves.WaveSimul","text":"abstract type WaveSimul{N}\n\nAbstract type for wave simulations.\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.build_wavesim-Tuple{SeismicWaves.InputParameters}","page":"Home","title":"SeismicWaves.build_wavesim","text":"build_wavesim(\n    params::SeismicWaves.InputParameters;\n    parall,\n    kwargs...\n)\n\n\nBuilds a wave similation based on the input paramters params and keyword arguments kwargs.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ngradient::Bool = false: whether the wave simulation is used for gradients computations.\ncheck_freq::Union{<:Integer, Nothing} = nothing: if gradient = true and if specified, enables checkpointing and specifies the checkpointing frequency.\nsnapevery::Union{<:Integer, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays (only for forward simulations).\ninfoevery::Union{<:Integer, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.gaussderivstf-Tuple{Real, Real, Real}","page":"Home","title":"SeismicWaves.gaussderivstf","text":" $(TYPEDSIGNATURES)\n\nFirst derivative of gaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.gaussstf-Tuple{Real, Real, Real}","page":"Home","title":"SeismicWaves.gaussstf","text":" $(TYPEDSIGNATURES)\n\nGaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.rickerstf-Tuple{Real, Real, Real}","page":"Home","title":"SeismicWaves.rickerstf","text":"$(TYPEDSIGNATURES)\n\nRicker source (second derivative of gaussian) source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.swforward!-Union{Tuple{N}, Tuple{SeismicWaves.InputParameters{N}, SeismicWaves.MaterialProperties{N}, Vector{<:Shot}}} where N","page":"Home","title":"SeismicWaves.swforward!","text":"swforward!(\n    params::SeismicWaves.InputParameters{N},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    parall,\n    snapevery,\n    infoevery,\n    logger\n) -> Union{Nothing, Vector{AbstractArray}}\n\n\nCompute forward simulation using the given input parameters params and material properties matprop on multiple shots. Receivers traces are stored in the Receivers object for each shot. See also Receivers.\n\nReturn a vector of snapshots for every shot if snapshotting is enabled.\n\nSee also Sources, Receivers.\n\nPositional arguments\n\nparams::InputParameters{N}: input parameters for the simulation, where N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{N}: material properties for the simulation,  where N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\nsnapevery::Union{Int, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays.  \ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.swforward!-Union{Tuple{N}, Tuple{Union{WaveSimul{N}, Vector{<:WaveSimul{N}}}, SeismicWaves.MaterialProperties{N}, Vector{<:Shot}}} where N","page":"Home","title":"SeismicWaves.swforward!","text":"swforward!(\n    wavesim::Union{WaveSimul{N}, Array{<:WaveSimul{N}, 1}},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    logger,\n    kwargs...\n) -> Any\n\n\nCompute forward simulation using a previously constructed WaveSimul object. Return a vector of snapshots for every shot if snapshotting is enabled.\n\nSee also Sources, Receivers.\n\nPositional arguments\n\nwavesim::Union{WaveSimul{N},Vector{<:WaveSimul{N}}}: input WaveSimul object containing all required information to run the simulation.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\nsnapevery::Union{Int, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays.  \ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.swgradient!-Union{Tuple{N}, Tuple{SeismicWaves.InputParameters{N}, SeismicWaves.MaterialProperties{N}, Vector{<:Shot}}} where N","page":"Home","title":"SeismicWaves.swgradient!","text":"swgradient!(\n    params::SeismicWaves.InputParameters{N},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    parall,\n    check_freq,\n    infoevery,\n    compute_misfit,\n    misfit,\n    smooth_radius,\n    logger\n) -> Union{Tuple{AbstractArray, Real}, AbstractArray}\n\n\nCompute gradients w.r.t. model parameters using the given input parameters params and material parameters matprop on multiple shots.\n\nThe check_freq parameter controls the checkpoiting frequency for adjoint computation. If nothing, no checkpointing is performed. If greater than 2, a checkpoint is saved every check_freq time step. The optimal tradeoff value is check_freq = sqrt(nt) where nt is the number of time steps of the forward simulation. Bigger values speed up computation at the cost of using more memory.\n\nSee also Sources, Receivers, swforward!, swmisfit!.\n\nPositional arguments\n\nparams::InputParameters{N}: input parameters for the simulation, where N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{N}: material properties for the simulation,  where N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ncheck_freq::Union{Int, Nothing} = nothing: if specified, enables checkpointing and specifies the checkpointing frequency.\ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\ncompute_misfit::Bool = false: if true, also computes and return misfit value.\nsmooth_radius::Integer = 5: grid points inside a ball with radius specified by the parameter (in grid points) will have their gradient smoothed by a factor inversely proportional to their distance from sources positions.\nlogger::Union{Nothing,AbstractLogger}: specifies the logger to be used. \n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.swgradient!-Union{Tuple{N}, Tuple{Union{WaveSimul{N}, Vector{<:WaveSimul{N}}}, SeismicWaves.MaterialProperties{N}, Vector{<:Shot}}} where N","page":"Home","title":"SeismicWaves.swgradient!","text":"swgradient!(\n    wavesim::Union{WaveSimul{N}, Array{<:WaveSimul{N}, 1}},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    logger,\n    kwargs...\n) -> Any\n\n\nCompute gradients w.r.t. model parameters using the previously built WaveSimul. This avoids re-initializing and re-allocating several arrays in case of multiple gradient calculations.\n\nThe check_freq parameter controls the checkpoiting frequency for adjoint computation. If nothing, no checkpointing is performed. If greater than 2, a checkpoint is saved every check_freq time step. The optimal tradeoff value is check_freq = sqrt(nt) where nt is the number of time steps of the forward simulation. Bigger values speed up computation at the cost of using more memory.\n\nSee also Sources, Receivers, swforward!, swmisfit!.\n\nPositional arguments\n\nwavesim::Union{WaveSimul{N},Vector{<:WaveSimul{N}}}: input WaveSimul object containing all required information to run the simulation.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ncheck_freq::Union{Int, Nothing} = nothing: if specified, enables checkpointing and specifies the checkpointing frequency.\ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\ncompute_misfit::Bool = false: if true, also computes and return misfit value.\nsmooth_radius::Integer = 5: grid points inside a ball with radius specified by the parameter (in grid points) will have their gradient smoothed by a factor inversely proportional to their distance from sources positions.\nlogger::Union{Nothing,AbstractLogger}: specifies the logger to be used. \n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.swmisfit!-Union{Tuple{N}, Tuple{SeismicWaves.InputParameters{N}, SeismicWaves.MaterialProperties{N}, Vector{<:Shot}}} where N","page":"Home","title":"SeismicWaves.swmisfit!","text":"swmisfit!(\n    params::SeismicWaves.InputParameters{N},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    parall,\n    misfit,\n    logger\n) -> Real\n\n\nReturn the misfit w.r.t. observed data by running a forward simulation using the given input parameters params and material properties matprop on multiple shots.\n\nPositional arguments\n\nparams::InputParameters{N}: input parameters for the simulation, where N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{N}: material properties for the simulation,  where N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\n\nReceivers traces are stored in the Receivers object for each shot.\n\nSee also Sources, Receivers, swforward!.\n\n\n\n\n\n","category":"method"},{"location":"#SeismicWaves.swmisfit!-Union{Tuple{N}, Tuple{Union{WaveSimul{N}, Vector{<:WaveSimul{N}}}, SeismicWaves.MaterialProperties{N}, Vector{<:Shot}}} where N","page":"Home","title":"SeismicWaves.swmisfit!","text":"swmisfit!(\n    wavesim::Union{WaveSimul{N}, Array{<:WaveSimul{N}, 1}},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    logger,\n    kwargs...\n) -> Any\n\n\nReturn the misfit w.r.t. observed data by running a forward simulation using the given WaveSimul object as an input.\n\nPositional arguments\n\nwavesim::Union{WaveSimul{N},Vector{<:WaveSimul{N}}}: input WaveSimul object containing all required information to run the simulation.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\n\nReceivers traces are stored in the Receivers object for each shot.\n\nSee also Sources, Receivers, swforward!.\n\n\n\n\n\n","category":"method"}]
}
