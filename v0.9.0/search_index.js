var documenterSearchIndex = {"docs":
[{"location":"guide/#User-guide","page":"User guide","title":"User guide","text":"Warning: User guide is currently work in progress!\n\nSee the Examples for how to use this package!\n\nSee the API for detailed information about the functionalities of this package!","category":"section"},{"location":"api/#api","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Input-parameters","page":"API","title":"Input parameters","text":"","category":"section"},{"location":"api/#Input-BDCs-parameters","page":"API","title":"Input BDCs parameters","text":"","category":"section"},{"location":"api/#Material-properties","page":"API","title":"Material properties","text":"","category":"section"},{"location":"api/#Shots,-sources-and-receivers","page":"API","title":"Shots, sources and receivers","text":"","category":"section"},{"location":"api/#Solver-functions","page":"API","title":"Solver functions","text":"","category":"section"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/#SeismicWaves.InputParameters","page":"API","title":"SeismicWaves.InputParameters","text":"abstract type InputParameters{T, N}\n\nInputParameters is the abstract supertype describing input parameters for wave simulations.\n\nCurrently implemented concrete parameters are InputParametersAcoustic and InputParametersElastic, for acoustic and elasic wave simulation respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.InputParametersAcoustic","page":"API","title":"SeismicWaves.InputParametersAcoustic","text":"struct InputParametersAcoustic{T, N} <: InputParameters{T, N}\n\nParameters for acoustic wave simulations.\n\nntimesteps::Int64: Number of time steps\ndt::Any: Time step\ngridsize::NTuple{N, Int64} where N: Grid size for each dimension\ngridspacing::NTuple{N, T} where {T, N}: Grid spacing in each direction\nboundcond::InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.InputParametersElastic","page":"API","title":"SeismicWaves.InputParametersElastic","text":"struct InputParametersElastic{T, N} <: InputParameters{T, N}\n\nParameters for elastic wave simulations\n\nntimesteps::Int64: Number of time steps\ndt::Any: Time step\ngridsize::NTuple{N, Int64} where N: Grid size for each dimension\ngridspacing::NTuple{N, T} where {T, N}: Grid spacing in each direction\nboundcond::InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.CPMLBoundaryConditionParameters","page":"API","title":"SeismicWaves.CPMLBoundaryConditionParameters","text":"struct CPMLBoundaryConditionParameters{T} <: InputBoundaryConditionParameters{T}\n\nCPML boundary conditions parameters for wave simulations.\n\nhalo::Int64: Number of CPML grid points\nrcoef::Any: Target reflection coefficient\nfreeboundtop::Bool: Free surface boundary condition at the top\nvel_max::Union{Nothing, T} where T: Maximum velocity for C-PML coefficients\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.InputBoundaryConditionParameters","page":"API","title":"SeismicWaves.InputBoundaryConditionParameters","text":"abstract type InputBoundaryConditionParameters{T}\n\nInputBoundaryConditionParameters is the abstract supertype describing boundary conditions input parameters for wave simulations.\n\nCurrently implemented concrete parameters are CPMLBoundaryConditionParameters and ReflectiveBoundaryConditionParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ReflectiveBoundaryConditionParameters","page":"API","title":"SeismicWaves.ReflectiveBoundaryConditionParameters","text":"struct ReflectiveBoundaryConditionParameters{T, N} <: InputBoundaryConditionParameters{T}\n\nReflective boundary conditions parameters for wave simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ElasticIsoMaterialProperties","page":"API","title":"SeismicWaves.ElasticIsoMaterialProperties","text":"mutable struct ElasticIsoMaterialProperties{T, N} <: SeismicWaves.AbstrElasticIsoMaterialProperties{T, N}\n\nMaterial properties for elastic isotropic simulation.\n\nλ::Array: First Lamé parameter\nμ::Array: Second Lamé parameter (shear modulus)\nρ::Array: Density\ninterp_method_ρ::SeismicWaves.AbstractInterpolationMethod: Interpolation method for density\ninterp_method_λ::SeismicWaves.AbstractInterpolationMethod: Interpolation method for density\ninterp_method_μ::SeismicWaves.AbstractInterpolationMethod: Interpolation method for density\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.MaterialProperties","page":"API","title":"SeismicWaves.MaterialProperties","text":"abstract type MaterialProperties{T, N}\n\nMaterialProperties is the abstract supertype describing material properties for wave simulations. It defines which type of wave equation is solved.\n\nCurrently implemented concrete properties are:\n\nVpAcousticCDMaterialProperties for acoustic constant density wave equation\nVpRhoAcousticVDMaterialProperties for acoustic variable density wave equation\nElasticIsoMaterialProperties for elasitic isotropic wave equation\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VpAcousticCDMaterialProperties","page":"API","title":"SeismicWaves.VpAcousticCDMaterialProperties","text":"struct VpAcousticCDMaterialProperties{T, N} <: MaterialProperties{T, N}\n\nMaterial properties for acoustic constant-density simulation.\n\nvp::Array: P-wave velocity\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VpRhoAcousticVDMaterialProperties","page":"API","title":"SeismicWaves.VpRhoAcousticVDMaterialProperties","text":"mutable struct VpRhoAcousticVDMaterialProperties{T, N} <: MaterialProperties{T, N}\n\nMaterial properties for acoustic variable-density simulation.\n\nvp::Array: P-wave velocity\nrho::Array: Density\ninterp_method::SeismicWaves.AbstractInterpolationMethod: Interpolation method\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VpRhoAcousticVDMaterialProperties-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Array{T, N}}} where {T, N}","page":"API","title":"SeismicWaves.VpRhoAcousticVDMaterialProperties","text":"VpRhoAcousticVDMaterialProperties(\n  vp::Array{T, N},\n  rho::Array{T, N};\n  interp_method::InterpolationMethod=ArithmeticAverageInterpolation()\n) where {T, N}\n\nConstructor for material properties for acoustic variable-density simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.ExternalForceShot","page":"API","title":"SeismicWaves.ExternalForceShot","text":"struct ExternalForceShot{T, N} <: Shot{T}\n\nType representing a shot with external force sources and multi-component receivers.\n\nsrcs::ExternalForceSources: Structure containing the ExternalForcesSources for a given simulation.\nrecs::VectorReceivers: Structure containing the VectorReceivers for a given simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.MomentTensorShot","page":"API","title":"SeismicWaves.MomentTensorShot","text":"struct MomentTensorShot{T, N, M<:SeismicWaves.MomentTensor{T, N}} <: Shot{T}\n\nType representing a shot with moment tensor sources and multi-component receivers.\n\nsrcs::MomentTensorSources: Structure containing the MomentTensorSources for a given simulation.\nrecs::VectorReceivers: Structure containing the VectorReceivers for a given simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.MomentTensorSources","page":"API","title":"SeismicWaves.MomentTensorSources","text":"Type representing a multi-source configuration for a wave propagation shot.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.MomentTensorSources-Union{Tuple{M}, Tuple{N}, Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Vector{M}, T}} where {T, N, M<:SeismicWaves.MomentTensor{T, N}}","page":"API","title":"SeismicWaves.MomentTensorSources","text":"MomentTensorSources( \n    positions::Matrix{T},\n    tf::Matrix{T},\n    momtens::Vector{M}\n    domfreq::T\n) where {T, N, M <: MomentTensor{T}}\n\nCreate a single shot wave propagation source configuration from source positions, time-functions and a dominant frequency.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.Receivers","page":"API","title":"SeismicWaves.Receivers","text":"abstract type Receivers{T}\n\nSources is the abstract supertype describing seismic receivers.\n\nCurrently implemented concrete receivers types are:\n\nScalarReceivers for scalar field receivers\nVectorReceivers for vector field receivers\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarReceivers","page":"API","title":"SeismicWaves.ScalarReceivers","text":"struct ScalarReceivers{T} <: Receivers{T}\n\nType representing a multi-receiver configuration for a wave propagation shot.\n\npositions::Matrix: Receiver positions\nseismograms::Matrix: Array holding seismograms (as columns)\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarReceivers-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T","page":"API","title":"SeismicWaves.ScalarReceivers","text":"ScalarReceivers(\n    positions::Array{T, 2},\n    nt::Int64\n) -> ScalarReceivers\n\n\nCreate a single shot wave propagation receivers configuration from receiver positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.ScalarShot","page":"API","title":"SeismicWaves.ScalarShot","text":"struct ScalarShot{T} <: Shot{T}\n\nType representing a shot with scalar sources and receivers.\n\nsrcs::ScalarSources: Structure containing the ScalarSources for a given simulation.\nrecs::ScalarReceivers: Structure containing the ScalarReceivers for a given simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarSources","page":"API","title":"SeismicWaves.ScalarSources","text":"struct ScalarSources{T} <: Sources{T}\n\nType representing a multi-source configuration for a wave propagation shot.\n\npositions::Matrix: Source positions\ntf::Matrix: Source time function\ndomfreq::Any: Dominant frequency\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.ScalarSources-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T}} where T","page":"API","title":"SeismicWaves.ScalarSources","text":"ScalarSources(positions::Matrix{T}, tf::Matrix{T}, domfreq::T) where {T}\n\nCreate a single shot wave propagation source configuration from source positions, time-functions and a dominant frequency.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.Shot","page":"API","title":"SeismicWaves.Shot","text":"abstract type Shot{T}\n\nShot is the abstract supertype describing a shot composed of sources and receivers.\n\nCurrently implemented concrete shot types are:\n\nScalarShot for scalar field sources and receivers\nMomentTensorShot for moment tensor sources and vector field receivers\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.Sources","page":"API","title":"SeismicWaves.Sources","text":"abstract type Sources{T}\n\nSources is the abstract supertype describing seismic sources.\n\nCurrently implemented concrete sources types are:\n\nScalarSources for scalar field sources\nMomentTensorSources for moment tensor sources\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VectorReceivers","page":"API","title":"SeismicWaves.VectorReceivers","text":"struct VectorReceivers{T, N} <: Receivers{T}\n\nType representing a multi-receiver configuration for a wave propagation shot.\n\npositions::Matrix: Receiver positions\nseismograms::Array{T, 3} where T: Array holding seismograms (as columns)\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.VectorReceivers-Union{Tuple{T}, Tuple{Matrix{T}, Int64}, Tuple{Matrix{T}, Int64, Int64}} where T","page":"API","title":"SeismicWaves.VectorReceivers","text":"VectorReceivers(\n    positions::Array{T, 2},\n    nt::Int64\n) -> VectorReceivers\nVectorReceivers(\n    positions::Array{T, 2},\n    nt::Int64,\n    ndim::Int64\n) -> VectorReceivers\n\n\nCreate a single shot wave propagation receivers configuration from receiver positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeismicWaves.swforward!","page":"API","title":"SeismicWaves.swforward!","text":"swforward!(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1};\n    runparams\n)\n\n\nCompute forward simulation using the given input parameters params and material properties matprop on multiple shots. Receivers traces are stored in the receivers for each shot.\n\nReturn a vector of Dict containing for each shot the snapshots of the fields computed in the simulation for each timestep.\n\nPositional arguments\n\nparams::InputParameters{T, N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation type.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation type.\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nrunparams::RunParameters: a struct containing parameters related to forward calculations. See RunParameters for details. In case of a forward simulation, gradparams is set to nothing.\n\nSee also InputParameters, MaterialProperties and Shot.\n\n\n\n\n\nswforward!(\n    wavesim::Union{WaveSimulation{T, N}, Array{<:WaveSimulation{T, N}, 1}},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1}\n) -> Any\n\n\nCompute forward simulation using a previously constructed WaveSimulation object. See also build_wavesim on how to build the WaveSimulation. Receivers traces are stored in the receivers for each shot.\n\nReturn a vector of Dict containing for each shot the snapshots of the fields computed in the simulation for each timestep.\n\nPositional arguments\n\nwavesim: wave simulation object containing all required information to run the simulation.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation type.\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nSee also InputParameters, MaterialProperties and Shot.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.swmisfit!","page":"API","title":"SeismicWaves.swmisfit!","text":"swmisfit!(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1},\n    misfit::Array{<:AbstractMisfit{T}, 1};\n    runparams\n)\n\n\nReturn the misfit w.r.t. observed data by running a forward simulation using the given input parameters params and material properties matprop on multiple shots. Receivers traces are stored in the receivers for each shot.\n\nPositional arguments\n\nparams::InputParameters{T, N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nthe Metal.jl GPU backend performing automatic domain decomposition if set to :Metal\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\nlogger::Union{Nothing,AbstractLogger}: specifies the logger to be used.\n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swgradient! and Shot.\n\n\n\n\n\nswmisfit!(\n    wavesim::Union{WaveSimulation{T, N}, Array{<:WaveSimulation{T, N}, 1}},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1},\n    misfit::Array{<:AbstractMisfit{T}, 1}\n) -> Any\n\n\nReturn the misfit w.r.t. observed data by running a forward simulation using the given WaveSimulation object as an input. Receivers traces are stored in the receivers for each shot. See also build_wavesim on how to build the WaveSimulation.\n\nPositional arguments\n\nwavesim::Union{WaveSimulation{T,N},Vector{<:WaveSimulation{T,N}}}: input WaveSimulation object containing all required information to run the simulation.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nthe Metal.jl GPU backend performing automatic domain decomposition if set to :Metal\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swgradient! and Shot.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.swgradient!","page":"API","title":"SeismicWaves.swgradient!","text":"swgradient!(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1},\n    misfit::Array{<:AbstractMisfit{T}, 1};\n    runparams,\n    gradparams\n) -> Any\n\n\nCompute gradients w.r.t. model parameters using the given input parameters params and material parameters matprop on multiple shots.\n\nThe check_freq parameter controls the checkpoiting frequency for adjoint computation. If nothing, no checkpointing is performed. If greater than 2, a checkpoint is saved every check_freq time step. The optimal tradeoff value is check_freq = sqrt(nt) where nt is the number of time steps of the forward simulation. Bigger values speed up computation at the cost of using more memory.\n\nPositional arguments\n\nparams::InputParameters{T, N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nrunparams::RunParameters: a struct containing parameters related to forward calculations. See RunParameters for details. In case of a forward simulation, gradparams is set to nothing.\ngradparams::Union{GradParameters,Nothing}: a struct containing parameters related to gradient calculations. See GradParameters for details.\n\nReturn\n\nThe gradient as a dictionary, one key per each material property. If compute_misfit in gradparams is set to true, additionally returns also the misfit value.\n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swmisfit! and Shot.\n\n\n\n\n\nswgradient!(\n    wavesim::Union{WaveSimulation{T, N}, Array{<:WaveSimulation{T, N}, 1}},\n    matprop::MaterialProperties{T, N},\n    shots::Array{<:Shot{T}, 1},\n    misfit::Array{<:AbstractMisfit{T}, 1}\n) -> Any\n\n\nCompute gradients w.r.t. model parameters using the previously built WaveSimulation. This avoids re-initializing and re-allocating several arrays in case of multiple gradient calculations. See also build_wavesim on how to build the WaveSimulation.\n\nThe check_freq parameter controls the checkpoiting frequency for adjoint computation. If nothing, no checkpointing is performed. If greater than 2, a checkpoint is saved every check_freq time step. The optimal tradeoff value is check_freq = sqrt(nt) where nt is the number of time steps of the forward simulation. Bigger values speed up computation at the cost of using more memory.\n\nPositional arguments\n\nwavesim::Union{WaveSimulation{T,N},Vector{<:WaveSimulation{T,N}}}: input WaveSimulation object containing all required information to run the simulation.\nmatprop::MaterialProperties{T, N}: material properties for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., Vp only is required for an acoustic constant-density simulation).\nshots::Vector{<:Shot{T}}: a vector whose elements are Shot structures. Each shot contains information about both source(s) and receiver(s).\n\nKeyword arguments\n\nrunparams::RunParameters: a struct containing parameters related to forward calculations. See RunParameters for details. In case of a forward simulation, gradparams is set to nothing.\ngradparams::Union{GradParameters,Nothing}: a struct containing parameters related to gradient calculations. See GradParameters for details.\n\nReturn\n\nThe gradient as a dictionary, one key per each material property. If compute_misfit in gradparams is set to true, additionally returns also the misfit value.\n\nSee also InputParameters, MaterialProperties and Shot. See also swforward! and swmisfit! and Shot.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.RunParameters","page":"API","title":"SeismicWaves.RunParameters","text":"struct RunParameters\n\nRunParameters is a struct containing various parameters related to forward (and gradient) simulations.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :CUDA\nthe AMDGPU.jl GPU backend performing automatic domain decomposition if set to :AMDGPU\nthe Metal.jl GPU backend performing automatic domain decomposition if set to :Metal\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\nsnapevery::Union{<:Int, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays (only for forward simulations).\ninfoevery::Union{<:Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\nlogger::AbstractLogger=current_logger(): specifies the logger to be used.\nerroronCFL::Bool=true: throw an error if the CFL condition is not met.\nminPPW::Int=10: minimum number of points per wavelength (PPW).\nerroronPPW::Bool=true: throw an error if the minimum number of points per wavelength (PPW) is not achieved (otherwise warn about it).\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.GradParameters","page":"API","title":"SeismicWaves.GradParameters","text":"struct GradParameters\n\nGradParameters is a struct containing various parameters related specifically to gradient simulations.\n\nKeyword arguments\n\nmute_radius_src::Int=0: grid points inside a ball with radius specified by the parameter (in grid points) will have their gradient smoothed by a factor inversely proportional to their distance from source positions.\nmute_radius_rec::Int=0: grid points inside a ball with radius specified by the parameter (in grid points) will have their gradient smoothed by a factor inversely proportional to their distance from receiver positions.\ncompute_misfit::Bool=false: default false. If true, also computes and returns the misfit value.\ncheck_freq::Int=1: if specified, enables checkpointing and defines the checkpointing frequency. Deafults to no checkpointing (=1).\n\n\n\n\n\n","category":"type"},{"location":"api/#SeismicWaves.build_wavesim","page":"API","title":"SeismicWaves.build_wavesim","text":"build_wavesim(\n    params::InputParameters{T, N},\n    matprop::MaterialProperties{T, N};\n    runparams,\n    gradparams,\n    kwargs...\n)\n\n\nBuilds a wave simulation object based on the input paramters params and keyword arguments kwargs.\n\nPositional arguments\n\nparams::InputParameters{T,N}: input parameters for the simulation, where T represents the data type and N represents the number of dimensions. They vary depending on the simulation kind (e.g., acoustic variable-density).\nmatprop::MaterialProperties{T, N}: material properties.\n\nKeyword arguments\n\ngradient::Bool = false: whether the wave simulation is used for gradients computations or not.\nrunparams::RunParameters: a struct containing parameters related to forward calculations. See RunParameters for details. \ngradparams::Union{GradParameters,Nothing}: a struct containing parameters related to gradient calculations. See GradParameters for details. In case of a forward simulation, gradparams is set to nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.gaussstf","page":"API","title":"SeismicWaves.gaussstf","text":"gaussstf(t::Real, t0::Real, f0::Real) -> Real\n\n\nGaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.gaussderivstf","page":"API","title":"SeismicWaves.gaussderivstf","text":"gaussderivstf(t::Real, t0::Real, f0::Real) -> Real\n\n\nFirst derivative of gaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"api/#SeismicWaves.rickerstf","page":"API","title":"SeismicWaves.rickerstf","text":"rickerstf(t::Real, t0::Real, f0::Real) -> Real\n\n\nRicker source (second derivative of gaussian) source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Acoustic-wave-simulation-example","page":"Examples","title":"Acoustic wave simulation example","text":"using SeismicWaves\n\n# numerics\nnt = 1500\ndt = 0.0012\ndh = 8.0\nt = collect(Float64, range(0.0; step=dt, length=nt)) ## time vector\n\n# create a velocity model (gradient from top to bottom)\nnx = 211\nnz = 120\nvelmod = zeros(nx, nz)\nfor i in 1:nx\n    for j in 1:nz\n        velmod[i, j] = 2000.0 + 12.0 * (j - 1)\n    end\nend\nmatprop = VpAcousticCDMaterialProperties(velmod)\n\n# shots definition\nnshots = 6\nshots = Vector{ScalarShot{Float64}}()\n# sources x-position (in grid points) (different for every shot)\nixsrc = round.(Int, LinRange(32, nx - 31, nshots))\nfor i in 1:nshots\n    # sources definition\n    nsrc = 1\n    possrcs = zeros(1, 2)                ## 1 source, 2 dimensions\n    possrcs[:, 1] .= (ixsrc[i] - 1) * dh    ## x-positions in meters\n    possrcs[:, 2] .= 2 * dh                 ## y-positions in meters\n    # source time functions\n    srcstf = zeros(nt, nsrc)\n    for s in 1:nsrc\n        srcstf[:, s] .= 1000.0 .* rickerstf.(t, 1.20 / 12.0, 12.0)\n    end\n    srcs = ScalarSources(possrcs, srcstf, 12.0)\n\n    # receivers definition\n    nrecs = 20\n    # receivers x-positions (in grid points) (same for every shot)\n    ixrec = round.(Int, LinRange(30, nx - 29, nrecs))\n    posrecs = zeros(nrecs, 2)              ## 20 receivers, 2 dimensions\n    posrecs[:, 1] .= (ixrec .- 1) .* dh    ## x-positions in meters\n    posrecs[:, 2] .= 2 * dh                ## y-positions in meters\n    recs = ScalarReceivers(posrecs, nt)\n\n    # add pair as shot\n    push!(shots, ScalarShot(; srcs=srcs, recs=recs)) ## srcs => recs)\nend\n\n# Input parameters for acoustic simulation\nsnapevery = 100\nboundcond = CPMLBoundaryConditionParameters(; halo=20, rcoef=0.0001, freeboundtop=true)\nparams = InputParametersAcoustic(nt, dt, (nx, nz), (dh, dh), boundcond)\n\n# Compute the seismograms\nrunparams = RunParameters(parall=:threads,snapevery=snapevery)\n\nsnapshots = swforward!(\n    params,\n    matprop,\n    shots;\n    runparams=runparams\n)","category":"section"},{"location":"examples/#Elastic-wave-simulation-example","page":"Examples","title":"Elastic wave simulation example","text":"# time stuff\nnt = 3000 #1500\ndt = 0.0008\nt = collect(Float64, range(0.0; step=dt, length=nt)) # seconds\n\n# create a velocity model\nnx = 380 ## 211\nnz = 270 ## 120\ndh = 4.5 ## meters\n\nvp = zeros(nx, nz)\nvp[nx÷2+10:end, :] .= 3100.0\nfor i in 1:nx\n    for j in 1:nz\n        vp[i, j] = 2000.0 + dh * (j - 1)\n    end\nend\nvs = vp ./ sqrt(3)\n\nρ = 2100.0 * ones(nx, nz)\nμ = vs .^ 2 .* ρ  ## μ = Vs^2⋅ρ\nλ = (vp .^ 2 .* ρ) .- (2 .* μ)  ## λ = vp^2 · ρ - 2μ\n\nmatprop = ElasticIsoMaterialProperties(; λ=λ, μ=μ, ρ=ρ)\n\n# shots definition\nnshots = 1\nshots = Vector{MomentTensorShot{Float64, 2, MomentTensor2D{Float64}}}()\n\nfor i in 1:nshots\n    # sources definition\n    nsrc = 1\n    # sources x-position (in grid points) (different for every shot)\n    if nsrc == 1\n        ixsrc = [nx / 2]\n    else\n        ixsrc = round.(Int, LinRange(30, nx - 31, nsrc))\n    end\n    possrcs = zeros(nsrc, 2)    ## 1 source, 2 dimensions\n    for s in 1:nsrc\n        possrcs[s, 1] = (ixsrc[i] - 1) * dh .+ 0.124   ## x-positions in meters\n        possrcs[s, 2] = (nz / 2) * dh .+ 0.124 ## y-positions in meters\n    end\n\n    # source time functions\n    f0 = 12.0\n    t0 = 1.20 / f0\n    srcstf = zeros(nt, nsrc)\n    Mxx = zeros(nsrc)\n    Mzz = zeros(nsrc)\n    Mxz = zeros(nsrc)\n    for s in 1:nsrc\n        srcstf[:, s] .= rickerstf.(t, t0, f0)\n        Mxx[s] = 5e10\n        Mzz[s] = 5e10\n        Mxz[s] = 0.89e10\n    end\n\n    srcs = MomentTensorSources(\n        possrcs, srcstf,\n        [MomentTensor2D(; Mxx=Mxx[s], Mzz=Mzz[s], Mxz=Mxz[s]) for s in 1:nsrc],\n        f0\n    )\n\n    # receivers definition\n    nrecs = 10\n    # receivers x-positions (in grid points) (same for every shot)\n    ixrec = round.(Int, LinRange(40, nx - 40, nrecs))\n    posrecs = zeros(nrecs, 2)    ## 20 receivers, 2 dimensions\n    posrecs[:, 1] .= (ixrec .- 1) .* dh .- 0.324   ## x-positions in meters\n    posrecs[:, 2] .= 3 * dh                        ## y-positions in meters\n\n    ndim = 2\n    recs = VectorReceivers(posrecs, nt, ndim)\n\n    # add pair as shot\n    push!(shots, MomentTensorShot(; srcs=srcs, recs=recs)) # srcs => recs)\nend\n\n# Input parameters for elastic simulation\nsnapevery = 5\ninfoevery = 100\nfreetop = true\nhalo = 20\nrcoef = 0.0001\nboundcond = CPMLBoundaryConditionParameters(; halo=halo, rcoef=rcoef, freeboundtop=freetop)\nparams = InputParametersElastic(nt, dt, (nx, nz), (dh, dh), boundcond)\n\n# Compute the seismograms\nrunparams = RunParameters(parall=:threads,infoevery=infoevery,snapevery=snapevery)\n\nsnapshots = swforward!(\n    params,\n    matprop,\n    shots;\n    runparams=runparams\n)","category":"section"},{"location":"#SeismicWaves.jl","page":"Home","title":"SeismicWaves.jl","text":"SeismicWaves.jl is a Julia package for acoustic and elastic wave propagation simulations designed to be used in a Full-Waveform Inversion framework. It solves different flavours of the wave equation using the finite difference method.\n\nThe main features of SeismicWaves.jl are:\n\nforward wave simulations with multiple pairs of sources and receivers (shots)\n1D, 2D, and 3D acoustic wave simulations (constant density and variable density)\n2D P-SV elastic wave similations (isotropic)\nfree surface and C-PML absorbing boundary conditions supported\ngradients of misfit functions with respect to model parameters using the adjoint method \ncheckpointing of forward simulations for the adjoint method\ndevice agnostic backends (CPUs or GPUs) thanks to ParallelStencil.jl, including Threads, CUDA, AMDGPU and Metal.\n\nThis package additionally provides some functions to solve inverse problems using the Hamiltonian Monte Carlo (HMC) method, as part of the HMCLab framework. \n\nMore information and an extensive list of features can be found in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nWarning: Documentation is currently minimal and work in progress!\n\nSee the Examples for how to use this package!\n\nSee the API for detailed information about the functionalities of this package!","category":"section"}]
}
