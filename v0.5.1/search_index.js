var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"Author = \"Andrea Zunino\"\nAuthor = \"Giacomo Aloisi\"\nEditURL = \"https://gitlab.com/JuliaGeoph/SeismicWaves.jl/-/tree/main/docs/src/\"","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 4","category":"page"},{"location":"#User-guide","page":"Home","title":"User guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeismicWaves is a Julia package for seismic wave propagation using the finite difference method. SeismicWaves provides functions to solve the forward problem and the gradient of a misfit functional with respect to model parameters. This package additionally provides some functions to solve inverse problems using the Hamiltonian Monte Carlo (HMC) method, as part of the HMCLab framework. ","category":"page"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeismicWaves\nInputParametersAcoustic\nInputParametersAcousticVariableDensity\nCPMLBoundaryConditionParameters\nReflectiveBoundaryConditionParameters\nVpAcousticCDMaterialProperty\nVpRhoAcousticVDMaterialProperty\nWaveSimul\nScalarSources\nScalarReceivers\nShot\nswforward!\nswmisfit!\nswgradient!\nbuild_wavesim\ngaussource1D \ngaussdersource1D\nrickersource1D","category":"page"},{"location":"#SeismicWaves","page":"Home","title":"SeismicWaves","text":"Module for generalized wave propagation solvers.\n\n\n\n\n\n","category":"module"},{"location":"#SeismicWaves.InputParametersAcoustic","page":"Home","title":"SeismicWaves.InputParametersAcoustic","text":"struct InputParametersAcoustic{N} <: SeismicWaves.InputParameters{N}\n\nParameters for acoustic wave simulations.\n\nntimesteps::Int64: Number of time steps\ndt::Real: Time step\ngridsize::Tuple{Vararg{var\"#s278\", N}} where {N, var\"#s278\"<:Int64}: Grid size for each dimension\ngridspacing::Tuple{Vararg{var\"#s277\", N}} where {N, var\"#s277\"<:Real}: Grid spacing in each direction\nboundcond::SeismicWaves.InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.InputParametersAcousticVariableDensity","page":"Home","title":"SeismicWaves.InputParametersAcousticVariableDensity","text":"struct InputParametersAcousticVariableDensity{N} <: SeismicWaves.InputParameters{N}\n\nParameters for variable-density acoustic wave simulations.\n\nntimesteps::Int64: Number of time steps\ndt::Real: Time step\ngridsize::Tuple{Vararg{var\"#s278\", N}} where {N, var\"#s278\"<:Int64}: Grid size for each dimension\ngridspacing::Tuple{Vararg{var\"#s277\", N}} where {N, var\"#s277\"<:Real}: Grid spacing in each direction\nboundcond::SeismicWaves.InputBoundaryConditionParameters: Kind of boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.CPMLBoundaryConditionParameters","page":"Home","title":"SeismicWaves.CPMLBoundaryConditionParameters","text":"struct CPMLBoundaryConditionParameters <: SeismicWaves.InputBoundaryConditionParameters\n\nCPML boundary conditions parameters for acoustic wave simulations.\n\nhalo::Int64: Number of CPML grid points\nrcoef::Real: Target reflection coefficient\nfreeboundtop::Bool: Free surface boundary condition at the top\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.ReflectiveBoundaryConditionParameters","page":"Home","title":"SeismicWaves.ReflectiveBoundaryConditionParameters","text":"struct ReflectiveBoundaryConditionParameters <: SeismicWaves.InputBoundaryConditionParameters\n\nReflective boundary conditions parameters for acoustic wave simulations.\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.VpAcousticCDMaterialProperty","page":"Home","title":"SeismicWaves.VpAcousticCDMaterialProperty","text":"struct VpAcousticCDMaterialProperty{N} <: SeismicWaves.MaterialProperties{N}\n\nMaterial properties for acoustic constant-density simulation.\n\nvp::Array{<:Float64, N} where N: P-wave velocity\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.VpRhoAcousticVDMaterialProperty","page":"Home","title":"SeismicWaves.VpRhoAcousticVDMaterialProperty","text":"mutable struct VpRhoAcousticVDMaterialProperty{N} <: SeismicWaves.MaterialProperties{N}\n\nMaterial properties for acoustic variable-density simulation.\n\nvp::Array{<:Float64, N} where N: P-wave velocity\nrho::Array{<:Float64, N} where N: Density\ninterp_method::SeismicWaves.InterpolationMethod: Interpolation method\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.WaveSimul","page":"Home","title":"SeismicWaves.WaveSimul","text":"abstract type WaveSimul{N}\n\nAbstract type for wave simulations.\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.ScalarSources","page":"Home","title":"SeismicWaves.ScalarSources","text":"Type representing a multi-source configuration for a wave propagation shot.\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.ScalarReceivers","page":"Home","title":"SeismicWaves.ScalarReceivers","text":"Type representing a multi-receiver configuration for a wave propagation shot.\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.Shot","page":"Home","title":"SeismicWaves.Shot","text":"Type representing a source-receiver pair, i.e., a \"shot\".\n\n\n\n\n\n","category":"type"},{"location":"#SeismicWaves.swforward!","page":"Home","title":"SeismicWaves.swforward!","text":"swforward!(\n    params::SeismicWaves.InputParameters{N},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    parall,\n    snapevery,\n    infoevery,\n    logger\n) -> Union{Nothing, Vector{AbstractArray}}\n\n\nCompute forward simulation using the given input parameters params and material properties matprop on multiple shots. Receivers traces are stored in the Receivers object for each shot. See also Receivers.\n\nReturn a vector of snapshots for every shot if snapshotting is enabled.\n\nSee also Sources, Receivers.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\nsnapevery::Union{Int, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays.  \ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\n\n\n\n\n\n","category":"function"},{"location":"#SeismicWaves.swmisfit!","page":"Home","title":"SeismicWaves.swmisfit!","text":"swmisfit!(\n    params::SeismicWaves.InputParameters{N},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    parall,\n    misfit,\n    logger\n) -> Real\n\n\nReturn the misfit w.r.t. observed data by running a forward simulation using the given input parameters params and material properties matprop on multiple shots.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:     - the CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU     - Base.Threads CPU threads performing automatic domain decomposition if set to :threads     - Base.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc     - otherwise the serial version if set to :serial\n\nReceivers traces are stored in the Receivers object for each shot.\n\nSee also Sources, Receivers, swforward!.\n\n\n\n\n\n","category":"function"},{"location":"#SeismicWaves.swgradient!","page":"Home","title":"SeismicWaves.swgradient!","text":"swgradient!(\n    params::SeismicWaves.InputParameters{N},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    parall,\n    check_freq,\n    infoevery,\n    compute_misfit,\n    misfit,\n    smooth_radius,\n    logger\n) -> Union{Tuple{AbstractArray, Real}, AbstractArray}\n\n\nCompute gradients w.r.t. model parameters using the given input parameters params and material parameters matprop on multiple shots.\n\nThe check_freq parameter controls the checkpoiting frequency for adjoint computation. If nothing, no checkpointing is performed. If greater than 2, a checkpoint is saved every check_freq time step. The optimal tradeoff value is check_freq = sqrt(nt) where nt is the number of time steps of the forward simulation. Bigger values speed up computation at the cost of using more memory.\n\nSee also Sources, Receivers, swforward!, swmisfit!.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ncheck_freq::Union{Int, Nothing} = nothing: if specified, enables checkpointing and specifies the checkpointing frequency.\ninfoevery::Union{Int, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\ncompute_misfit::Bool = false: if true, also computes and return misfit value.\nsmooth_radius::Integer = 5: grid points inside a ball with radius specified by the parameter (in grid points) will have their gradient smoothed by a factor inversely proportional to their distance from sources positions.\nlogger::Union{Nothing,AbstractLogger}: specifies the logger to be used. \n\n\n\n\n\nswgradient!(\n    wavesim::Union{WaveSimul{N}, Array{<:WaveSimul{N}, 1}},\n    matprop::SeismicWaves.MaterialProperties{N},\n    shots::Vector{<:Shot};\n    logger,\n    kwargs...\n) -> Any\n\n\nCompute gradients w.r.t. model parameters using the previously built WaveSimul. This avoids re-initializing and re-allocating several arrays in case of multiple gradient calculations.\n\n\n\n\n\n","category":"function"},{"location":"#SeismicWaves.build_wavesim","page":"Home","title":"SeismicWaves.build_wavesim","text":"build_wavesim(\n    params::SeismicWaves.InputParameters;\n    parall,\n    kwargs...\n)\n\n\nBuilds a wave similation based on the input paramters params and keyword arguments kwargs.\n\nKeyword arguments\n\nparall::Symbol = :threads: controls which backend is used for computation:\nthe CUDA.jl GPU backend performing automatic domain decomposition if set to :GPU\nBase.Threads CPU threads performing automatic domain decomposition if set to :threads\nBase.Threads CPU threads sending a group of sources to each thread if set to :threadpersrc\notherwise the serial version if set to :serial\ngradient::Bool = false: whether the wave simulation is used for gradients computations.\ncheck_freq::Union{<:Integer, Nothing} = nothing: if gradient = true and if specified, enables checkpointing and specifies the checkpointing frequency.\nsnapevery::Union{<:Integer, Nothing} = nothing: if specified, saves itermediate snapshots at the specified frequency (one every snapevery time step iteration) and return them as a vector of arrays (only for forward simulations).\ninfoevery::Union{<:Integer, Nothing} = nothing: if specified, logs info about the current state of simulation every infoevery time steps.\n\n\n\n\n\n","category":"function"},{"location":"#SeismicWaves.gaussource1D","page":"Home","title":"SeismicWaves.gaussource1D","text":"gaussource1D(t::Real, t0::Real, f0::Real)\n\nGaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"#SeismicWaves.gaussdersource1D","page":"Home","title":"SeismicWaves.gaussdersource1D","text":"gaussdersource1D(t::Real, t0::Real, f0::Real)\n\nFirst derivative of gaussian source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"},{"location":"#SeismicWaves.rickersource1D","page":"Home","title":"SeismicWaves.rickersource1D","text":"rickersource1D(t::Real, t0::Real, f0::Real)\n\nRicker source (second derivative of gaussian) source time function for current time t, activation time t0 and dominating frequency f0.\n\n\n\n\n\n","category":"function"}]
}
